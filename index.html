<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>CSV Column Viewer</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 24px; line-height: 1.4; }
    .row { display: flex; gap: 12px; flex-wrap: wrap; align-items: end; margin-bottom: 16px; }
    label { font-weight: 600; }
    select, input[type="file"], input[type="number"], button { padding: 8px 10px; font-size: 14px; }
    #status { color: #444; margin: 8px 0 16px; }
    #list { border: 1px solid #ddd; border-radius: 10px; padding: 12px; max-width: 980px; }
    .item { padding: 10px 8px; border-bottom: 1px solid #eee; word-break: break-word; }
    .item:last-child { border-bottom: none; }
    .muted { color: #666; font-size: 13px; }
    a { color: #0b5fff; text-decoration: none; }
    a:hover { text-decoration: underline; }
    .controls { gap: 10px; }
    .group { display:flex; gap:10px; flex-wrap: wrap; align-items: end; }
  </style>
</head>
<body>
  <h1>CSV Column Viewer</h1>

  <div class="row controls">
    <div>
      <label for="fileInput">CSV file:</label><br />
      <input id="fileInput" type="file" accept=".csv,text/csv" />
    </div>

    <div>
      <label for="columnSelect">Column:</label><br />
      <select id="columnSelect" disabled>
        <option value="">— Select a file first —</option>
      </select>
    </div>

    <div>
      <label for="hasHeader">Header row:</label><br />
      <select id="hasHeader">
        <option value="true" selected>Yes</option>
        <option value="false">No</option>
      </select>
    </div>

    <div>
      <label for="delimiter">Delimiter:</label><br />
      <select id="delimiter">
        <option value="auto" selected>Auto</option>
        <option value=",">Comma (,)</option>
        <option value=";">Semicolon (;)</option>
        <option value="\t">Tab</option>
        <option value="|">Pipe (|)</option>
      </select>
    </div>

    <div>
      <label>&nbsp;</label><br />
      <button id="renderBtn" disabled>Render</button>
    </div>
  </div>

  <div class="row">
    <div class="group">
      <div>
        <label for="batchSize">Open batch size:</label><br />
        <input id="batchSize" type="number" min="1" max="200" value="10" />
      </div>

      <div>
        <label>&nbsp;</label><br />
        <button id="openNextBtn" disabled>Open next links</button>
      </div>

      <div>
        <label>&nbsp;</label><br />
        <button id="resetOpenBtn" disabled>Reset opening to start</button>
      </div>
    </div>
  </div>

  <div id="status" class="muted">Choose a CSV to begin.</div>
  <div id="list" aria-live="polite"></div>

<script>
(() => {
  const fileInput = document.getElementById('fileInput');
  const columnSelect = document.getElementById('columnSelect');
  const hasHeaderSel = document.getElementById('hasHeader');
  const delimiterSel = document.getElementById('delimiter');
  const renderBtn = document.getElementById('renderBtn');
  const statusEl = document.getElementById('status');
  const listEl = document.getElementById('list');

  const batchSizeEl = document.getElementById('batchSize');
  const openNextBtn = document.getElementById('openNextBtn');
  const resetOpenBtn = document.getElementById('resetOpenBtn');

  let parsed = { headers: [], rows: [] };

  // For "open next" feature:
  let currentColIdx = null;
  let linkQueue = [];     // array of urls (in row order) from selected column
  let openCursor = 0;     // next index in linkQueue to open

  fileInput.addEventListener('change', async () => {
    resetUI();
    const file = fileInput.files?.[0];
    if (!file) return;

    const text = await file.text();
    const delim = delimiterSel.value === 'auto' ? sniffDelimiter(text) : delimiterSel.value;
    const hasHeader = hasHeaderSel.value === 'true';

    try {
      parsed = parseCSV(text, delim);
      if (parsed.rows.length === 0) {
        setStatus('No rows found in the CSV.');
        return;
      }

      const headers = hasHeader ? parsed.rows[0] : makeDefaultHeaders(parsed.rows[0].length);
      const dataRows = hasHeader ? parsed.rows.slice(1) : parsed.rows;

      // Normalize row lengths
      const width = headers.length;
      const normalizedRows = dataRows.map(r => padRow(r, width));

      parsed = { headers, rows: normalizedRows };

      populateColumnSelect(headers);
      setStatus(`Loaded ${file.name}: ${parsed.rows.length} data rows, ${headers.length} columns. Delimiter: ${visibleDelimiter(delim)}.`);
      renderBtn.disabled = false;
      columnSelect.disabled = false;

      // Disable open buttons until a column is rendered/selected
      openNextBtn.disabled = true;
      resetOpenBtn.disabled = true;

      // Auto-select first column
      columnSelect.selectedIndex = 0;
      currentColIdx = Number(columnSelect.value);
      if (Number.isFinite(currentColIdx)) renderColumn(currentColIdx);
    } catch (e) {
      console.error(e);
      setStatus('Failed to parse CSV. Try a different delimiter or check the file format.');
    }
  });

  hasHeaderSel.addEventListener('change', () => { if (fileInput.files?.[0]) fileInput.dispatchEvent(new Event('change')); });
  delimiterSel.addEventListener('change', () => { if (fileInput.files?.[0]) fileInput.dispatchEvent(new Event('change')); });

  renderBtn.addEventListener('click', () => {
    const idx = Number(columnSelect.value);
    if (!Number.isFinite(idx)) return;
    renderColumn(idx);
  });

  columnSelect.addEventListener('change', () => {
    const idx = Number(columnSelect.value);
    if (Number.isFinite(idx)) renderColumn(idx);
  });

  openNextBtn.addEventListener('click', () => {
    const n = clampInt(batchSizeEl.value, 1, 200, 10);
    openNextBatch(n);
  });

  resetOpenBtn.addEventListener('click', () => {
    openCursor = 0;
    setStatus(openStatusLine());
  });

  function resetUI() {
    listEl.innerHTML = '';
    columnSelect.innerHTML = '<option value="">— Select —</option>';
    columnSelect.disabled = true;
    renderBtn.disabled = true;
    openNextBtn.disabled = true;
    resetOpenBtn.disabled = true;
    linkQueue = [];
    openCursor = 0;
    currentColIdx = null;
  }

  function setStatus(msg) {
    statusEl.textContent = msg;
  }

  function populateColumnSelect(headers) {
    columnSelect.innerHTML = headers
      .map((h, i) => `<option value="${i}">${escapeHtml(h || `Column ${i+1}`)}</option>`)
      .join('');
  }

  function renderColumn(colIdx) {
    currentColIdx = colIdx;
    listEl.innerHTML = '';
    linkQueue = [];
    openCursor = 0;

    let shown = 0;
    let nonEmpty = 0;

    for (const row of parsed.rows) {
      const raw = (row[colIdx] ?? '').trim();
      if (raw === '') continue;

      nonEmpty++;

      const { node, url } = makeLinkishNodeAndUrl(raw);
      if (url) linkQueue.push(url);

      const div = document.createElement('div');
      div.className = 'item';
      div.appendChild(node);
      listEl.appendChild(div);
      shown++;
    }

    openNextBtn.disabled = linkQueue.length === 0;
    resetOpenBtn.disabled = linkQueue.length === 0;

    if (shown === 0) {
      listEl.innerHTML = `<div class="item muted">No non-empty values in this column.</div>`;
    }

    setStatus(openStatusLine(nonEmpty));
  }

  function openStatusLine(nonEmptyOverride) {
    const colName = (currentColIdx != null)
      ? (parsed.headers[currentColIdx] || `Column ${currentColIdx+1}`)
      : '—';

    const nonEmptyText = (typeof nonEmptyOverride === 'number')
      ? `${nonEmptyOverride} non-empty values. `
      : '';

    if (linkQueue.length === 0) {
      return `Showing “${colName}”. ${nonEmptyText}No link-like rows detected to open.`;
    }
    return `Showing “${colName}”. ${nonEmptyText}Detected ${linkQueue.length} link-like rows. Next to open: ${openCursor + 1} of ${linkQueue.length}.`;
  }

  function openNextBatch(batchSize) {
    if (linkQueue.length === 0) return;

    const start = openCursor;
    const end = Math.min(openCursor + batchSize, linkQueue.length);
    if (start >= end) {
      setStatus(`All detected links have been opened. (Total: ${linkQueue.length})`);
      return;
    }

    // Open in new tabs (may be blocked if pop-up settings are strict)
    for (let i = start; i < end; i++) {
      window.open(linkQueue[i], '_blank', 'noopener,noreferrer');
    }

    openCursor = end;
    setStatus(`Opened ${end - start} tab(s). Next to open: ${openCursor + 1} of ${linkQueue.length}.`);
  }

  // --- Link detection / rendering ---

  function makeLinkishNodeAndUrl(value) {
    // Support markdown-ish [text](url)
    const md = value.match(/^\s*\[([^\]]+)\]\(([^)]+)\)\s*$/);
    if (md) {
      const text = md[1].trim();
      const urlRaw = md[2].trim();
      const url = normalizeUrl(urlRaw);
      const a = document.createElement('a');
      a.href = url;
      a.textContent = text;
      a.target = '_blank';
      a.rel = 'noopener noreferrer';
      return { node: a, url };
    }

    // Email
    if (looksLikeEmail(value)) {
      const url = `mailto:${value}`;
      const a = document.createElement('a');
      a.href = url;
      a.textContent = value;
      return { node: a, url };
    }

    // URL (with or without scheme)
    if (looksLikeUrl(value)) {
      const url = normalizeUrl(value);
      const a = document.createElement('a');
      a.href = url;
      a.textContent = value;
      a.target = '_blank';
      a.rel = 'noopener noreferrer';
      return { node: a, url };
    }

    // Fallback: plain text
    return { node: document.createTextNode(value), url: null };
  }

  function normalizeUrl(url) {
    if (/^[a-zA-Z][a-zA-Z0-9+.-]*:\/\//.test(url)) return url;
    if (/^www\./i.test(url)) return `https://${url}`;
    if (/^[^\s]+\.[a-z]{2,}([\/?#].*)?$/i.test(url)) return `https://${url}`;
    return url;
  }

  function looksLikeEmail(s) {
    return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(s);
  }

  function looksLikeUrl(s) {
    if (/^[a-zA-Z][a-zA-Z0-9+.-]*:\/\//.test(s)) return true;
    if (/^www\./i.test(s)) return true;
    return /^[^\s]+\.[a-z]{2,}([\/?#].*)?$/i.test(s);
  }

  function clampInt(val, min, max, fallback) {
    const n = Number(val);
    if (!Number.isFinite(n)) return fallback;
    return Math.max(min, Math.min(max, Math.floor(n)));
  }

  // --- CSV parsing (handles quotes, commas inside quotes, CRLF, etc.) ---

  function parseCSV(text, delimiter) {
    const rows = [];
    let row = [];
    let field = '';
    let i = 0;
    let inQuotes = false;

    text = text.replace(/\r\n/g, '\n').replace(/\r/g, '\n');

    while (i < text.length) {
      const c = text[i];

      if (inQuotes) {
        if (c === '"') {
          if (text[i + 1] === '"') {
            field += '"';
            i += 2;
            continue;
          } else {
            inQuotes = false;
            i++;
            continue;
          }
        } else {
          field += c;
          i++;
          continue;
        }
      } else {
        if (c === '"') { inQuotes = true; i++; continue; }

        if (c === delimiter) {
          row.push(field);
          field = '';
          i++;
          continue;
        }

        if (c === '\n') {
          row.push(field);
          rows.push(row);
          row = [];
          field = '';
          i++;
          continue;
        }

        field += c;
        i++;
      }
    }

    row.push(field);
    if (!(row.length === 1 && row[0] === '' && rows.length > 0)) rows.push(row);

    if (rows[0] && rows[0][0]) rows[0][0] = rows[0][0].replace(/^\uFEFF/, '');

    const filtered = rows.filter(r => r.some(cell => String(cell).trim() !== ''));
    return { rows: filtered };
  }

  function sniffDelimiter(text) {
    const sample = text.slice(0, 20000).replace(/\r\n/g, '\n').replace(/\r/g, '\n');
    const lines = sample.split('\n').slice(0, 10).filter(Boolean);
    const candidates = [',', ';', '\t', '|'];

    const scoreFor = (delim) => {
      let score = 0;
      for (const line of lines) score += countDelimOutsideQuotes(line, delim);
      return score;
    };

    let best = ',';
    let bestScore = -1;
    for (const c of candidates) {
      const s = scoreFor(c);
      if (s > bestScore) { bestScore = s; best = c; }
    }
    return bestScore <= 0 ? ',' : best;
  }

  function countDelimOutsideQuotes(line, delim) {
    let inQuotes = false;
    let count = 0;
    for (let i = 0; i < line.length; i++) {
      const ch = line[i];
      if (ch === '"') {
        if (inQuotes && line[i + 1] === '"') { i++; continue; }
        inQuotes = !inQuotes;
      } else if (!inQuotes && ch === delim) {
        count++;
      }
    }
    return count;
  }

  function makeDefaultHeaders(n) {
    return Array.from({ length: n }, (_, i) => `Column ${i + 1}`);
  }

  function padRow(row, width) {
    const r = row.slice(0, width);
    while (r.length < width) r.push('');
    return r;
  }

  function escapeHtml(str) {
    return String(str).replace(/[&<>"']/g, (m) => ({
      '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;'
    }[m]));
  }

  function visibleDelimiter(d) {
    if (d === '\t') return 'Tab';
    return d;
  }
})();
</script>
</body>
</html>
